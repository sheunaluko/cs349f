#ifndef TRADER_TRADER_API_H_
#define TRADER_TRADER_API_H_

#define MARKET_DATA_LIMIT (100000)
#include <limits.h>
#include <stdint.h>

#include <algorithm>
#include <map>
#include <mutex>
#include <string>
#include <vector>

#include "common/message_types.h"
#include "common/network_utils.h"
#include "common/redis_data_structures.h"
#include "database/data_aggregator.h"
#include "trader/market_data_api.h"

class Trader {
 public:
  // Construct a Trader object. Set the redis_logging flag to true in order to
  // enable tracking of your outstanding orders, your completed trades, and the
  // state of your portfolio.
  Trader(const std::string &gateway_ip, const std::string &client_id,
         const std::string &authentication_token);

  ~Trader();

  // The submitOrder method accepts the symbol to be traded, a reference to an
  // Order object (which will be populated by the method with the full order
  // object that was generated by the gateway), the order type (limit or
  // market), the order action (buy or sell), the number of shares (must be >
  // 0), and the limit price (must be > 0). The return code will be one of:
  //
  //   malformed        Invalid Symbol, Action, Type, Shares, or Price
  //   error            Request Timeout or Network Error
  //   invalid          Insufficient Balance in Portfolio
  //   valid            Successfully Processed by Matching Engine
  //   duplicate        This Order has a Duplicate Serial Number
  OrderResult SubmitOrder(const std::string &symbol, Order *order,
                          OrderType type, OrderAction action, int num_shares,
                          int limit_price);

  // The submitCancel method accepts the id of the order that the user
  // wishes to cancel. Furthermore, the return code will be one of:
  //
  //   malformed        Invalid Order ID for Cancel Request
  //   error            Request Timeout or Network Error
  //   invalid          Order ID Nonexistant (in Limit Books)
  //   valid            Successfully Processed by Matching Engine
  //   duplicate        This Order has a Duplicate Serial Number
  //
  // Note that if you receive an invalid, you did not necessarily make a
  // mistake. It is possible that the order simply was fully filled by someone
  // else's order before your cancel got through the sequencing buffer.
  OrderResult SubmitCancel(const std::string &order_id);

  bool ConfigActiveSymbols(std::vector<std::string> active_symbols);

  bool GetRecentLOBs(std::string symbol, std::vector<LimitOrderBook> *ans_lob,
                     uint64_t start_timestamp);

  bool GetRecentTrades(std::string symbol, std::vector<Trade> *ans_trades,
                       uint64_t start_timestamp);

  // Redis wrappers
  bool GetOutstandingOrders(std::map<std::string, Order> *outstanding_orders);
  bool GetPortfolioMatrix(std::map<std::string, int> *portfolio_mtx);
  bool GetAllHistoricalOrders(std::vector<Order> *order_vec);
  bool GetAllHistoricalTrades(std::vector<Trade> *trade_vec);

  std::vector<std::string> GetSymbols();

 private:
  // Used in Construtor
  bool PullAllHistoricalOrdersFromBigTable(std::vector<Order> *order_vec);
  bool PullAllHistoricalTradesFromBigTable(std::vector<Trade> *trade_vec);

  // Thread function to continuously fetch matrket data for active symbol set
  void ActiveSymbolProcesserFunc();

  // Utility functions to check validity of user-inputted symbols
  bool CheckSymbolValidity(std::vector<std::string> active_symbols);
  bool CheckActiveSymbolValidity(const std::string &symbol);

  // ZMQ Context
  void *context_;

  // ZMQ Requester
  void *requester_;

  // ZMQ Pusher
  void *pusher_;

  // My Client ID
  std::string client_id_;

  // Assigned Gateway IP
  std::string gateway_ip_;

  // Incoming Data Buffer
  char buffer_[BUFFER_SIZE];

  // Set of Tradable Symbols
  std::vector<std::string> symbols_;

  // Holds (lob & trade) subscribers to all tradable symbols
  std::map<std::string, std::pair<LimitBookAPI *, TradeReportAPI *> >
      symbol_subscriber_apis_;

  // Set of Active Symbols
  std::vector<std::string> active_symbols_;
  std::map<std::string, std::mutex> symbol_mtxes;
  std::map<std::string, LimitOrderBook *> active_symbol_lobs_;
  std::map<std::string, uint64_t> active_symbol_lobs_counters_;
  std::map<std::string, Trade *> active_symbol_trades_;
  std::map<std::string, uint64_t> active_symbol_trades_counters_;
  std::thread *active_symbol_thread_;
  volatile bool active_thread_run_;

  // Trade Recorder Object Pointer
  TradeConfirmationAPI *trade_confirmation_api_;

  // Order Confirmation Recorder Object Pointer
  OrderConfirmationAPI *order_confirmation_api_;

  std::map<std::string, int> cache_map_;
  std::mutex cache_map_mutex_;

  // Thread to Capture My Trades
  std::thread *subscriber_thread_;

  // Thread to Capture Order Confirmation
  std::thread *confirmation_subscriber_thread_;

  // Authentication Token
  std::string authentication_token_;

  // Writing loggin statistics to bigtable
  DataAggregator *log_writer_;

  // Utility class to wrap around common redis operations
  REDISDataStructures *structures_;

  // Use this lock to maintain thread safety
  std::mutex thread_safety_lock_;
};

#endif  // TRADER_TRADER_API_H_
